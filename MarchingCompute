// Compute shader example
#pragma kernel FunctionKernel

// Input variable
float terrainSurface;
float cube[8];
bool smoothTerrain;
bool flatShaded;

AppendStructuredBuffer<float3> vertices;
AppendStructuredBuffer<int> triangles;

// Input array
float terrainMap[10][10][10];

float SampleTerrain (int3 point) {
   return terrainMap[point.x, point.y, point.z];
{

int GetCubeConfiguration (float cube[8]) {
  int configurationIndex = 0;
  for (int i = 0; i < 8; i++) {
    if (cube[i] > terrainSurface) {
      configurationIndex |= 1 << i;
    }
  }
  // Return the configuration index
  return configurationIndex;
}

int VertForIndice (float3 vert) {

  for (int i = 0; i < vertices.Count; i++) {

   if (vertices[i] == vert)
      return i;

  }
  vertices.Add(vert);
  return vertices.Count - 1;
}


// Kernel function
void main (uint3 id : SV_DispatchThreadID) {
  uint i = id.x;

  for (int i = 0; i < 8; i++) {
    cube[i] = SampleTerrain(int3(id) + CornerTable[i]);
  }

  int configIndex = GetCubeConfiguration(cube);

  if (configIndex == 0 || configIndex == 255)
            return;

  int edgeIndex = 0;
  for(int i = 0; i < 5; i++) {
      for(int p = 0; p < 3; p++) {

         int indice = TriangleTable[configIndex, edgeIndex];  

         if (indice == -1)
            return;

         int3 vert1 = int3(id) + CornerTable[EdgeIndexes[indice, 0]];
         int3 vert2 = int3(id) + CornerTable[EdgeIndexes[indice, 1]];

         int3 vertPosition;
         if (smoothTerrain) {

                    float vert1Sample = cube[EdgeIndexes[indice, 0]];
                    float vert2Sample = cube[EdgeIndexes[indice, 1]];

                    float difference = vert2Sample - vert1Sample;
                    if (difference == 0)
                        difference = terrainSurface;
                    else
                        difference = (terrainSurface - vert1Sample) / differece;

                   vertPosition = vert1 + ((vert2 - vert1) * difference);

         } else {
                
            vertPosition = (vert1 + vert2) / 2f;

         }

         if (flatShaded) {

             vertices.Append(vertPosition);
             triangles.Append(vertices.GetCounterValue - 1);

          } else
             triangles.Append(VertForIndice(vertPosition));

          edgeIndex++;

       }
   }
}
